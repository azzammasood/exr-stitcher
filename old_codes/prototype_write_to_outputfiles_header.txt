# Prototype to edit OutputFile's header to retain data
import glob
import os
import argparse
import numpy as np
import re
import OpenEXR as openexr
import Imath
from PIL import Image
import cv2
import inspect
import psutil
from memory_profiler import memory_usage
from memory_profiler import profile
import operator

_np_to_exr = {
    np.float16: Imath.PixelType.HALF,
    np.float32: Imath.PixelType.FLOAT,
    np.uint32: Imath.PixelType.UINT,
}
_exr_to_np = dict(zip(_np_to_exr.values(), _np_to_exr.keys()))


def main():
    # Add and read command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--input_folder', type=str, help='Directory where input images are located')
    parser.add_argument('--output_folder', type=str, help='Directory where output image should be written')
    args = parser.parse_args()

    os.chdir(args.input_folder)  # Changing directory to input folder

    files_first_convention = match_filenames('.exr',
                                             r'^u(?!0)\d{1,2}?_v(?!0)\d{1,2}?\.exr$')  # ^ matches start of string.

    # $ matches start of string.
    # u(?!0)\d? will match 'u' only if it's not followed by the digit 0. The ? matches 0 or 1 repitions of the preceding digit.

    files_first_convention = np.array(files_first_convention)

    files_second_convention = match_filenames('.exr', r'^u(?!0)\d{1,2}?_v(?!0)\d{1,2}?_(?!0)\d{1,2}?\.exr$')
    files_second_convention = np.array(files_second_convention)

    all_files = np.concatenate((files_first_convention, files_second_convention))

    rows_and_columns = []
    for filename in all_files:
        rows_and_columns.append(re.findall(r'\d+', filename))

    # print(rows_and_columns, "\n")
    rows = [row[0] for row in rows_and_columns]
    columns = [column[1] for column in rows_and_columns]
    paste = [paste[2] for paste in rows_and_columns if len(paste) > 2]

    # Reading the exr files in a list
    exr_files_list = []
    channel_names = []
    # Reading the exr files in a list
    for file in all_files:
        exr_file, channels = read_exr(file)
        exr_files_list.append(exr_file)
        channel_names.append(channels)

    # Calculate grid size
    grid_size = (max(rows), max(columns))

    # Check if all images have same channel configuration
    check_channels_similarity(exr_files_list)

    # Check if rows have same height and columns have same width
    window_height, window_width = check_heights_and_widths(exr_files_list, grid_size)

    # # Stitch images
    # # Stitch images horizontally
    rows = np.array_split(exr_files_list, int(grid_size[0]))

    # list_stitched_rows = []
    #
    # for row in rows:
    #     for img in range(4):
    #         if img == 0:
    #             stitched_row = row[img]
    #         else:
    #             stitched_row = np.concatenate((stitched_row, row[img]), axis=1)
    #     list_stitched_rows.append(stitched_row)
    #
    # # Stitch rows vertically
    # for row in range(len(list_stitched_rows)):
    #     if row == 0:
    #         stitched_vertically = list_stitched_rows[row]
    #     else:
    #         stitched_vertically = np.concatenate((stitched_vertically, list_stitched_rows[row]), axis=0)

    # data_window = ((0, 0), (rows[0][0].shape[1] - 1, rows[0][0].shape[0] - 1))
    # for i, row in enumerate(rows):
    #     print('This is row', i)
    #     if i > 0: # If not first row,
    #         data_window = ((0, data_window[0][1] + row[0].shape[1]), (row[0].shape[1] - 1, data_window[1][1] + row[0].shape[0]))
    #     for j, image in enumerate(row):
    #         display_window = (window_height, window_width)
    #         if j > 0:
    #             data_window = ((data_window[1][0] + 1, data_window[0][1]), (data_window[1][0] + image.shape[1], data_window[1][1]))
    #         print('Row ', i, ': ', data_window)
    #         if i == 0 and j == 0:
    #             write_exr(True, 'a.exr', image, data_window[0][0], data_window[0][1], data_window[1][0],
    #                       data_window[1][1], display_window, channel_names[0])
    #         else:
    #             write_exr(False, 'a.exr', image, data_window[0][0], data_window[0][1], data_window[1][0],
    #                       data_window[1][1], display_window, channel_names[0])

    # New
    display_window = (window_height, window_width)
    write_exr('Stitched.exr', rows, display_window, channel_names[0])

# @profile
def write_exr(filename, rows_of_images, display_window, channel_names):
    """Writes the values in a multi-channel ndarray into an EXR file.

  Args:
    filename: The filename of the output file
    values: A numpy ndarray with shape [height, width, channels]
    channel_names: A list of strings with length = channels

  Raises:
    TypeError: If the numpy array has an unsupported type.
    ValueError: If the length of the array and the length of the channel names
      list do not match.
  """
    header = openexr.Header(display_window[1], display_window[0])
    try:
        exr_channel_type = Imath.PixelType(_np_to_exr[rows_of_images[0][0].dtype.type])
    except KeyError:
        raise TypeError('Unsupported numpy type: %s' % str(rows_of_images[0][0].dtype))
    header['channels'] = {
        n: Imath.Channel(exr_channel_type) for n in channel_names
    }

    # Create initial data window
    data_window = ((0, 0), (rows_of_images[0][0].shape[1] - 1, rows_of_images[0][0].shape[0] - 1))
    header['dataWindow'] = Imath.Box2i(Imath.V2i(data_window[0][0], data_window[0][1]), Imath.V2i(data_window[1][0], data_window[1][1]))

    # Open the output file for writing
    exr = openexr.OutputFile(filename, header)

    for i, row in enumerate(rows_of_images):
        print('This is row', i)
        if i > 0:  # If not first row,
            data_window = ((0, data_window[0][1] + row[0].shape[1]), (row[0].shape[1] - 1, data_window[1][1] + row[0].shape[0]))
            exr.header['dataWindow'] = Imath.Box2i(Imath.V2i(data_window[0][0], data_window[0][1]), Imath.V2i(data_window[1][0], data_window[1][1]))
        for j, image in enumerate(row):
            if j > 0:
                data_window = ((data_window[1][0] + 1, data_window[0][1]), (data_window[1][0] + image.shape[1], data_window[1][1]))
                exr.header['dataWindow'] = Imath.Box2i(Imath.V2i(data_window[0][0], data_window[0][1]), Imath.V2i(data_window[1][0], data_window[1][1]))
            print('Row ', i, ': ', data_window)

        channel_data = [image[..., i] for i in range(image.shape[-1])]  # List of lists, each sublist containing channel data

        for x, y, z in zip(*channel_data):
            one_scanline = [x, y, z]
            scanline = dict((n, d.tobytes()) for n, d in zip(channel_names, one_scanline))
            exr.writePixels(scanline, 1)

    exr.close()

def read_exr(filename, channel_names=None):
    """Opens an EXR file and copies the requested channels into an ndarray.

  The Python openexr wrapper uses a dictionary for the channel header, so the
  ordering of the channels in the underlying file is lost. If channel_names is
  not passed, this function orders the output channels with any present RGBA
  channels first, followed by the remaining channels in alphabetical order.
  By convention, RGBA channels are named 'R', 'G', 'B', 'A', so this function
  looks for those strings.

  Args:
    filename: The name of the EXR file.
    channel_names: A list of strings naming the channels to read. If None, all
      channels will be read.

  Returns:
    A numpy array containing the image data, and a list of the corresponding
      channel names.
  """
    exr = openexr.InputFile(filename)
    if channel_names is None:
        remaining_channel_names = list(exr.header()['channels'].keys())
        conventional_rgba_names = ['R', 'G', 'B', 'A']
        present_rgba_names = []
        # Pulls out any present RGBA names in RGBA order.
        for name in conventional_rgba_names:
            if name in remaining_channel_names:
                present_rgba_names.append(name)
                remaining_channel_names.remove(name)
        channel_names = present_rgba_names + sorted(remaining_channel_names)

    return np.array(channels_to_ndarray(exr, channel_names)), channel_names

def channels_to_ndarray(exr, channel_names):
    """Copies channels from an openexr.InputFile into a numpy array.

  If the EXR image is of size (width, height), the result will be a numpy array
  of shape (height, width, len(channel_names)), where the last dimension holds
  the channels in the order they were specified in channel_names. The requested
  channels must all have the same datatype.

  Args:
    exr: An openexr.InputFile that is already open.
    channel_names: A list of strings naming the channels to read.

  Returns:
    A numpy ndarray.

  Raises:
    ValueError: If the channels have different datatypes.
    RuntimeError: If a channel has an unknown type.
  """
    channels_header = exr.header()['channels']
    window = exr.header()['dataWindow']
    width = window.max.x - window.min.x + 1
    height = window.max.y - window.min.y + 1

    def read_channel(channel):
        """Reads a single channel from the EXR."""
        channel_type = channels_header[channel].type
        try:
            numpy_type = _exr_to_np[channel_type.v]
        except KeyError:
            raise RuntimeError('Unknown EXR channel type: %s' % str(channel_type))
        flat_buffer = np.frombuffer(exr.channel(channel), numpy_type)
        return np.reshape(flat_buffer, [height, width])

    channels = [read_channel(c) for c in channel_names]
    if any([channels[0].dtype != c.dtype for c in channels[1:]]):
        raise ValueError('Channels have mixed datatypes: %s' %
                         ', '.join([str(c.dtype) for c in channels]))
    # Stack the arrays so that the channels dimension is the last (fastest
    # changing) dimension.
    return np.stack(channels, axis=-1)


def match_filenames(file_extension, regular_expression):
    return [file for file in glob.glob('*' + file_extension)
            if re.match(regular_expression, file)]


def check_channels_similarity(list_of_images):
    channels = []
    for image in list_of_images:
        channels.append(image.shape[-1])
    assert len(set(channels)) == 1, "All images must have same channels"


def getnameofchannels(channels_list):
    if channels_list[0] == 1:
        return ['R']
    elif channels_list[0] == 2:
        return ['R', 'G']
    elif channels_list[0] == 3:
        return ['R', 'G', 'B']
    elif channels_list[0] == 4:
        return ['R', 'G', 'B', 'A']


def check_heights_and_widths(exr_files_list, grid_size):
    columns = exr_files_list[0::int(grid_size[1])]
    width_of_columns = [exr.shape[1] for exr in columns]
    assert len(set(width_of_columns)) == 1, "Widths of images in same column must be same"
    window_height = sum([exr.shape[0] for exr in columns])

    for i in range(0, len(exr_files_list), int(grid_size[0])):
        row = exr_files_list[i:i + 4]
        heights = []
        widths = []
        for j in row:
            heights.append(j.shape[0])
            assert len(set(heights)) == 1, "Heights of images in same row must be same"
            widths.append(j.shape[1])

    window_width = sum(widths)
    return window_height, window_width

if __name__ == '__main__':
    main()
