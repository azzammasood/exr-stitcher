import glob
import os
os.environ["OPENCV_IO_ENABLE_openexr"]="1"
import argparse
import numpy as np
import re
import OpenEXR as openexr
import Imath
from PIL import Image
import matplotlib.pyplot as plt

_np_to_exr = {
    np.float16: Imath.PixelType.HALF,
    np.float32: Imath.PixelType.FLOAT,
    np.uint32: Imath.PixelType.UINT,
}
_exr_to_np = dict(zip(_np_to_exr.values(), _np_to_exr.keys()))

def main():
    # Add and read command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--input_folder', type=str, help='Directory where input images are located')
    parser.add_argument('--output_folder', type=str, help='Directory where output image should be written')
    args = parser.parse_args()

    os.chdir(args.input_folder) # Changing directory to input folder

    files_first_convention = match_filenames('.exr', r'^u(?!0)\d{1,2}?_v(?!0)\d{1,2}?\.exr$') # ^ matches start of string.

                                                                                             # $ matches start of string.
                                                                                             # u(?!0)\d? will match 'u' only if it's not followed by the digit 0. The ? matches 0 or 1 repitions of the preceding digit.
    files_first_convention = np.array(files_first_convention)

    files_second_convention = match_filenames('.exr', r'^u(?!0)\d{1,2}?_v(?!0)\d{1,2}?_(?!0)\d{1,2}?\.exr$')
    files_second_convention = np.array(files_second_convention)

    all_files = np.concatenate((files_first_convention, files_second_convention))
    # print(all_files)

    rows_and_columns = []
    for filename in all_files:
        rows_and_columns.append(re.findall(r'\d+', filename))

    # print(rows_and_columns, "\n")
    rows = [row[0] for row in rows_and_columns]
    columns = [column[1] for column in rows_and_columns]
    paste = [paste[2] for paste in rows_and_columns if len(paste) > 2]

    # Reading the exr files and their channels, creating separate lists for both
    exr_files_list = []
    exr_files_channels = []

    for file in all_files:
        exr_file, channels = read_exr(file)
        exr_files_list.append(exr_file)
        exr_files_channels.append(channels)

    exr_files_numpy = np.array(exr_files_list, dtype="object")

    # for array in exr_files_numpy:
    #     sample = Image.fromarray(array.astype(np.uint8))
    #     r, g, b = sample.split()
    #     r = r.point(lambda i: i * 255)
    #     g = g.point(lambda i: i * 255)
    #     g = g.point(lambda i: i * 255)
    #     out = Image.merge('RGB', (r, g, b))
    sample = Image.fromarray(exr_files_numpy[0].astype(np.uint8))
    r, g, b = sample.split()
    r = r.point(lambda i: i * 255)
    g = g.point(lambda i: i * 255)
    g = g.point(lambda i: i * 255)
    out = Image.merge('RGB', (r, g, b))

    out.save('a.png')

def read_exr(filename, channel_names=None):
  """Opens an EXR file and copies the requested channels into an ndarray.

  The Python openexr wrapper uses a dictionary for the channel header, so the
  ordering of the channels in the underlying file is lost. If channel_names is
  not passed, this function orders the output channels with any present RGBA
  channels first, followed by the remaining channels in alphabetical order.
  By convention, RGBA channels are named 'R', 'G', 'B', 'A', so this function
  looks for those strings.

  Args:
    filename: The name of the EXR file.
    channel_names: A list of strings naming the channels to read. If None, all
      channels will be read.

  Returns:
    A numpy array containing the image data, and a list of the corresponding
      channel names.
  """
  exr = openexr.InputFile(filename)
  if channel_names is None:
    remaining_channel_names = list(exr.header()['channels'].keys())
    conventional_rgba_names = ['R', 'G', 'B', 'A']
    present_rgba_names = []
    # Pulls out any present RGBA names in RGBA order.
    for name in conventional_rgba_names:
      if name in remaining_channel_names:
        present_rgba_names.append(name)
        remaining_channel_names.remove(name)
    channel_names = present_rgba_names + sorted(remaining_channel_names)

  return channels_to_ndarray(exr, channel_names), channel_names

def channels_to_ndarray(exr, channel_names):
  """Copies channels from an openexr.InputFile into a numpy array.

  If the EXR image is of size (width, height), the result will be a numpy array
  of shape (height, width, len(channel_names)), where the last dimension holds
  the channels in the order they were specified in channel_names. The requested
  channels must all have the same datatype.

  Args:
    exr: An openexr.InputFile that is already open.
    channel_names: A list of strings naming the channels to read.

  Returns:
    A numpy ndarray.

  Raises:
    ValueError: If the channels have different datatypes.
    RuntimeError: If a channel has an unknown type.
  """
  channels_header = exr.header()['channels']
  window = exr.header()['dataWindow']
  width = window.max.x - window.min.x + 1
  height = window.max.y - window.min.y + 1

  def read_channel(channel):
    """Reads a single channel from the EXR."""
    channel_type = channels_header[channel].type
    try:
      numpy_type = _exr_to_np[channel_type.v]
    except KeyError:
      raise RuntimeError('Unknown EXR channel type: %s' % str(channel_type))
    flat_buffer = np.frombuffer(exr.channel(channel), numpy_type)
    return np.reshape(flat_buffer, [height, width])

  channels = [read_channel(c) for c in channel_names]
  if any([channels[0].dtype != c.dtype for c in channels[1:]]):
    raise ValueError('Channels have mixed datatypes: %s' %
                     ', '.join([str(c.dtype) for c in channels]))
  # Stack the arrays so that the channels dimension is the last (fastest
  # changing) dimension.
  return np.stack(channels, axis=-1)

def match_filenames(file_extension, regular_expression):
    return [file for file in glob.glob('*'+file_extension)
            if re.match(regular_expression, file)]

if __name__ == '__main__':
    main()

